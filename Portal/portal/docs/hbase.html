<h2>HBase</h2>

<p>Aufgrund der Zielsetzung eine Platform f&uuml;r horizontal skalierbare Web-Anwendungen bereitzustellen, kommt in der TwoSpot-Plattform keine relationale Datenbank zum Einsatz. Anstelle dessen wird auf die Spalten-Basierte Datenbank HBase gesetzt. Diese basiert auf dem verteilten Dateisysteme HDFS, das den Kernbestandteil von Hadoop bildet.
</p>

<h3>Verwendung von HBase</h3>
<p>Im Unterschied zu relationalen Datenbanken stellt HBase keine SQL-Schnittstelle zur Verf&uuml;gung. Auch ein gro&szlig;teil der aus SQL-Datenbanken bekannten Funktionalit&auml;t wie Prim&auml;rschl&uuml;sse, Indices, Fremdschl&uuml;ssel oder Constraints steht bei Verwendung der HBase-Datenbank nicht zur Verf&uuml;gung.
</p>

<p>Der Zugriff auf die HBase-Datenbank aus TwoSpot-Anwendungen heraus erfolgt &uuml;ber JDO (Java Data Objects). JDO ist ein Standard der eine einheitliche Schnittstelle f&uuml;r das Arbeiten mit persistenten Daten beschreibt. Der Vorteil von JDO gegen&uuml;ber JPA (Java Persistence API), Hibernate oder anderen OR-Mappern liegt in der Unabh&auml;ngigkeit zu der zugrundeliegenden Speichertechnologie. Diese Eigenschaft wird auch als datastore-agnostic bezeichnet und bedeutet vereinfacht ausgedr&uuml;ckt, dass nicht nur relationale Datenbanken sondern jede beliebige Speicherl&ouml;sung eingesetzt werden k&ouml;nnen. Beispiele hierf&uuml;r sind Objektorientierte-, Dokumentenbasierte- oder auch Spalten-Basierte Datenbanken. Dementsprechend l&auml;sst sich JDO auch mit der HBase-Datenbank einsetzten. 
</p>

<h3>JDO in TwoSpot</h3>
<p>
Die TwoSpot-Plattform greift f&uuml;r die JDO-Implementierung auf das <a href="http://www.datanucleus.org/">DataNucleus-Framework</a> und das HBase- und H2-Plugin von DataNucleus zur&uuml;ck. Nachfolgend wird anhand eines einfachen Beispiels (Kommentarfunktion eines Blogs) gezeigt wie in TwoSpot Daten in die Datenbank geschrieben und wieder gelesen werden k&ouml;nnen. 
</p>

<p>
Im ersten Schritt muss die Struktur der zu speichernden Daten beschrieben werden. Dies erfolgt durch die Definition einer Klasse mit Attributen. Nachfolgend ist enie Klasse dargestellt die einen Kommentar mit einem Namen enth&auml;lt: 
</p>

<pre class="prettyprint lang-java">
public class BlogEntry
{
	private String username; 
	
	private String message;

	public String getUsername()
	{
		return username;
	}

	public void setUsername(String username)
	{
		this.username = username;
	}

	public String getMessage()
	{
		return message;
	}

	public void setMessage(String message)
	{
		this.message = message;
	}
}
</pre>

<p>
Anschlie&szlig;end m&uuml;ssen die Klasse und die persistenten Attribute annotiert werden. Die Klasse wird dabei mit <code>@PersistenceCapable</code> annotiert. Dar&uuml;ber erh&auml;lt JDO die Information, dass es sich um eine persistente Klasse handelt. Alle persistenten Attribute werden mit <code>@Persistent</code> annotiert. Diese Attribute werden von JDO gespeichert. Es ist dar&uuml;ber hinau&szlig; sinnvoll nicht persistente Attribute mit <code>@NotPersistent</code> zu annotieren. </p>
<p>Ein persistentes Klassen-Attribut muss als Prim&auml;rschl&uuml;ssel gekennzeichnet
    sein. Der Prim&auml;rschl&uuml;ssel kann entweder von der Anwendung generiert werden,
    oder es kann eine Generator-Strategie z.B. <code>UUIDSTRING</code> eingesetzt werden. </p>
<p>Die annotierte <code>BlogEntry</code>-Klasse hat das folgende Aussehen:
</p>

<pre class="prettyprint lang-java">
@PersistenceCapable
public class BlogEntry
{
	@Persistent(valueStrategy = IdGeneratorStrategy.UUIDSTRING)<br />	@PrimaryKey<br />	private String key;

	@Persistent
	private String username; 
	
	@Persistent
	private String message;

	public String getUsername()
	{
		return username;
	}

	public void setUsername(String username)
	{
		this.username = username;
	}

	public String getMessage()
	{
		return message;
	}

	public void setMessage(String message)
	{
		this.message = message;
	}
}
</pre>

<p>
Um Instanzen der <code>BlogEntry</code>-Klasse zu speichern muss eine <code>PersisteceManagerFactory</code> erzeugt werden. &uuml;ber diese kann ein <code>PersistenceManager</code> erzeugt werden. Mithilfe des <code>PersistenceManager</code>'s k&ouml;nnen persistence Objekte in der Datenbank gespeichert werden. 
</p>
<p>Das Anlegen einer neuen <code>PersistenceManagerFactory</code> ist sehr &quot;teuer&quot;. Aus diesem
    Grund empfiehlt es sich die Referenz in Form eines Singletons zu speichern. </p>
<p>
Der folgende Quellcodeausschnitt erstellt eine Instanz der <code>BlogEntry</code>-Klasse und speichert das Objet in der Datenbank. 
</p>

<pre class="prettyprint lang-java">
PersistenceManagerFactory pmf = JDOHelper.getPersistenceManagerFactory("etc/jdoDefault.properties");
PersistenceManager manager = pmf.getPersistenceManager();
Transaction tx = manager.currentTransaction();
tx.begin();

try
{

	BlogEntry entry = new BlogEntry();
	entry.setUsername("test");
	entry.setMessage("test");

	manager.makePersistent(entry);

	tx.commit();
} catch (Exception e)
{
	tx.rollback();
}
</pre>


